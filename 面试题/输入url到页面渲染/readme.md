# DNS 解析  IP协议
1. 客户端从本地服务器查找 IP
2. 再去根域名服务器查找
3. 再去顶级域名服务器查找
4. 目标服务器，找到了
5. 将IP缓存进本地的dns缓存区

# TCP
- 可靠性高
    1. 超时重传(TCP会备份数据包)
    2. 拥塞控制
    3. 丢包重传  (有序性)

- 效率低


- 三次握手
    1. 客户端给服务端发送建立连接的请求 SYN-SENT 状态
    2. 服务端向客户端发送已收到请求的应答 SYN-RECEIVED 状态
    3. 客户端接收到同意连接的应答，发送确认请求 双方进入 ESTABLISHED 状态

- 为什么两次握手不行

- HTTP数据传输

- 四次挥手断开连接
    1. 客户端请求完数据后发送断开连接请求
    2. 服务端收到断开连接请求后，通知应用层去释放TCP连接，此时不再接收客户端的请求了
    3. 服务端如果还有没有发送完的数据会继续发送，完毕后会向客户端发送释放连接的应答
    4. 客户端收到释放连接的应答后，向服务端发送确认应答

# UDP
- 不可靠
    1. 不需要建立连接
    2. 不会给数据包拼接过多字段
    3. 没有拥塞控制

- 效率高

- 应用场景
    游戏，直播，视频通话

# 浏览器获取到服务端资源后
- 解析HTML资源生成DOM树
    1. 浏览器接收到的是二进制的字节数据，浏览器会将这些二进制的数据转换成字符串
    2. 对字符串进行词法分析

- 解析CSS资源生成CSS树
- 合并DOM树和CSS树，生成render树
    1. 只会包含需要显示的节点
    2. 根据渲染树来布局页面(回流)
    3. GPU绘制，合成图层，显示在页面上(重绘)


# 回流
  修改一个元素的几何属性会导致回流
  1. 修改宽高
  2. 页面初次渲染
  3. 添加、删除元素
  4. 改变窗口大小

# 重绘

# 浏览器的优化策略
  当我们修改一个元素的几何属性导致浏览器需要回流时，浏览器会维护一个渲染队列，将需要回流的操作存入对列中，等到后续没有回流行为或者达到阈值时，会一次性将队列中的行为全部执行

  offsetXXXX
  clientXXXX

  会导致渲染队列强制刷新


# js 加载执行会阻塞html的渲染
  1. 在script标签上加 async,该js的加载就不会阻塞html的渲染


# js操作DOM慢？
  1. dom结构在js引擎眼里拥有很庞大的属性
  2. js引擎线程和渲染线程是互斥的，一旦js修改dom操作过多，线程之间的切换会带来性能消耗


# 